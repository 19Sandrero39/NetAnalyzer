use crate::net_analyzer::NetworkAnalyze;
use crate::net_analyzer::{get_network, input};
use std::collections::HashMap;
use std::fs::File;
use std::io::{Read, Write};

// ─────────────────────────────────────────────
// Создание новой записи сети
// ─────────────────────────────────────────────
/// Добавляет новую сетевую конфигурацию в базу данных.
/// Запрашивает у пользователя ключ для новой сети, а затем IP-адрес и маску.
/// Если ключ уже существует, пользователю сообщается об этом.
///
/// ### Аргументы
///
/// * `db` - Изменяемая ссылка на `HashMap`, где ключ - это `String`, а значение - `NetworkAnalyze`.
pub fn create(db: &mut HashMap<String, NetworkAnalyze>) {
    println!("\n╔═══════════════════════════════════════════════╗");
    println!("║              ➕ Добавление новой сети         ║");
    println!("╚═══════════════════════════════════════════════╝");
    let key: String = input("🔹 Введите ключ для новой сети: ");

    if db.contains_key(&key) {
        println!(
            "❌ Сеть с ключом [{}] уже существует! Используйте 'upd' для обновления.",
            key
        );
        return;
    }

    let (ip, mask, network, min_host, max_host, gateway, prefix_len, host_count) = get_network();

    let new_network: NetworkAnalyze = NetworkAnalyze::new(
        ip, mask, network, min_host, max_host, gateway, prefix_len, host_count,
    );

    db.insert(key.clone(), new_network);
    println!("✅ Сеть с ключом [{}] успешно создана!", key);
    println!("═════════════════════════════════════════════════\n");
}

// ─────────────────────────────────────────────
// Чтение записи по ключу
// ─────────────────────────────────────────────
/// Отображает подробную информацию о сетевой конфигурации, используя указанный ключ.
/// Если сеть с заданным ключом не найдена, выводится сообщение об ошибке.
///
/// ### Аргументы
///
/// * `db` - Неизменяемая ссылка на `HashMap`, содержащую сетевые конфигурации.
pub fn read(db: &HashMap<String, NetworkAnalyze>) {
    let key: String = input("🔹 Введите ключ сети для просмотра: ");
    match db.get(&key) {
        Some(info) => {
            println!("\n╔═══════════════════════════════════════════════╗");
            println!("║          📄 Информация о сети [{}]           ║", key);
            println!("╚═══════════════════════════════════════════════╝");

            println!("🔹 IP-адрес:            {}", info.ip);
            println!("🔹 Маска подсети:       {}", info.mask);
            println!("🔹 Сетевой адрес:       {}", info.network);
            println!("🔹 Длина префикса:      /{}", info.prefix_len);
            println!("🔹 Кол-во хостов:       {}", info.host_count);
            println!("🔹 Мин. адрес хоста:    {}", info.min_host);
            println!("🔹 Макс. адрес хоста:   {}", info.max_host);
            println!("🔹 Шлюз по умолчанию:   {}", info.gateway);
            println!("═════════════════════════════════════════════════\n");
        }
        None => println!("❌ Сеть с ключом [{}] не найдена!", key),
    }
}

// ─────────────────────────────────────────────
// Обновление существующей записи
// ─────────────────────────────────────────────
/// Обновляет существующую сетевую конфигурацию в базе данных.
/// Запрашивает ключ сети для обновления, затем запрашивает новые IP-адрес и маску.
/// Если сеть с заданным ключом не найдена, выводится сообщение об ошибке.
///
/// ### Аргументы
///
/// * `db` - Изменяемая ссылка на `HashMap`, где ключ - это `String`, а значение - `NetworkAnalyze`.
pub fn update(db: &mut HashMap<String, NetworkAnalyze>) {
    println!("\n╔═══════════════════════════════════════════════╗");
    println!("║            🔄 Обновление данных сети          ║");
    println!("╚═══════════════════════════════════════════════╝");
    let key: String = input("🔹 Введите ключ сети для обновления: ");

    if db.contains_key(&key) {
        println!("➡️ Введите новые данные для пересчёта:");

        let (ip, mask, network, min_host, max_host, gateway, prefix_len, host_count) =
            get_network();

        let updated_network: NetworkAnalyze = NetworkAnalyze::new(
            ip, mask, network, min_host, max_host, gateway, prefix_len, host_count,
        );

        db.insert(key.clone(), updated_network);
        println!("✅ Сеть с ключом [{}] успешно обновлена!", key);
    } else {
        println!("❌ Сеть с ключом [{}] не найдена!", key);
    }
    println!("═════════════════════════════════════════════════\n");
}

// ─────────────────────────────────────────────
// Удаление записи
// ─────────────────────────────────────────────
/// Удаляет сетевую конфигурацию из базы данных по указанному ключу.
/// Если сеть с заданным ключом не найдена, выводится сообщение об ошибке.
///
/// ### Аргументы
///
/// * `db` - Изменяемая ссылка на `HashMap`, где ключ - это `String`, а значение - `NetworkAnalyze`.
pub fn delete(db: &mut HashMap<String, NetworkAnalyze>) {
    println!("\n╔═══════════════════════════════════════════════╗");
    println!("║             🗑️ Удаление сети                  ║");
    println!("╚═══════════════════════════════════════════════╝");
    let key: String = input("🔹 Введите ключ сети для удаления: ");
    if db.remove(&key).is_some() {
        println!("✅ Сеть с ключом [{}] успешно удалена из базы!", key);
    } else {
        println!("❌ Мы не смогли найти сеть по указанному ключу [{}]!", key);
    }
    println!("═════════════════════════════════════════════════\n");
}

// ─────────────────────────────────────────────
// Вывод всех сетей
// ─────────────────────────────────────────────
/// Выводит список всех сохраненных сетевых конфигураций в базе данных.
/// Если база данных пуста, выводится соответствующее сообщение.
///
/// ### Аргументы
///
/// * `db` - Неизменяемая ссылка на `HashMap`, содержащую сетевые конфигурации.
pub fn list(db: &HashMap<String, NetworkAnalyze>) {
    println!("\n╔═══════════════════════════════════════════════╗");
    println!("║              📋 Список всех сетей             ║");
    println!("╚═══════════════════════════════════════════════╝");
    if db.is_empty() {
        println!("ℹ️ База данных пуста! Добавьте сети командой 'add'.");
    } else {
        for (key, net) in db {
            println!("➡️ Ключ: [{}]", key);
            println!("  IP-адрес: {}", net.ip);
            println!("  Маска: {}", net.mask);
            println!("  Сетевой адрес: {}", net.network);
            println!("  Длина префикса: /{}", net.prefix_len);
            println!("  Кол-во хостов: {}", net.host_count);
            println!("  Мин. хост: {}", net.min_host);
            println!("  Макс. хост: {}", net.max_host);
            println!("  Шлюз: {}", net.gateway);
            println!("-----------------------------------------------");
        }
    }
    println!("═════════════════════════════════════════════════\n");
}

// ─────────────────────────────────────────────
// Очистка всей базы
// ─────────────────────────────────────────────
/// Очищает всю базу данных сетевых конфигураций.
/// Перед выполнением операции запрашивает у пользователя подтверждение.
///
/// ### Аргументы
///
/// * `db` - Изменяемая ссылка на `HashMap`, где ключ - это `String`, а значение - `NetworkAnalyze`.
pub fn clear(db: &mut HashMap<String, NetworkAnalyze>) {
    println!("\n╔═══════════════════════════════════════════════╗");
    println!("║             ⚠️ Очистка всей базы               ║");
    println!("╚═══════════════════════════════════════════════╝");
    let confirm: String = input("⚠️ Вы уверены, что хотите удалить ВСЕ сети? (yes/no): ");
    if confirm.to_lowercase() == "yes" {
        db.clear();
        println!("✅ Все сети были успешно удалены!");
    } else {
        println!("❌ Операция отменена.");
    }
    println!("═════════════════════════════════════════════════\n");
}

// ─────────────────────────────────────────────
// Сравнение двух сетей
// ─────────────────────────────────────────────
/// Сравнивает две сетевые конфигурации по их ключам, указанным пользователем.
/// Выводит, находятся ли сети в одной подсети, и отображает их ключевые параметры для сравнения.
/// Если одна или обе сети не найдены, выводится сообщение об ошибке.
///
/// ### Аргументы
///
/// * `db` - Неизменяемая ссылка на `HashMap`, содержащую сетевые конфигурации.
pub fn compare(db: &HashMap<String, NetworkAnalyze>) {
    println!("\n╔═══════════════════════════════════════════════╗");
    println!("║              📊 Сравнение двух сетей          ║");
    println!("╚═══════════════════════════════════════════════╝");
    let first_key: String = input("🔹 Введите ключ первой сети [1]: ");
    let second_key: String = input("🔹 Введите ключ второй сети [2]: ");
    println!("═════════════════════════════════════════════════\n");

    let first: Option<&NetworkAnalyze> = db.get(&first_key);
    let second: Option<&NetworkAnalyze> = db.get(&second_key);

    if let (Some(f), Some(s)) = (first, second) {
        println!(
            "🔍 Результат сравнения сетей [{}] и [{}]",
            first_key, second_key
        );
        println!("----------------------------------------------");

        if f.network == s.network && f.mask == s.mask {
            println!("✅ Сети находятся в одной подсети!");
        } else {
            println!("❌ Сети находятся в разных подсетях.");
        }

        println!("→ IP [1]:   {}    | IP [2]:   {}", f.ip, s.ip);
        println!("→ Сеть:     {}    | {}", f.network, s.network);
        println!("→ Маска:    {}    | {}", f.mask, s.mask);
        println!("→ Префикс:  /{}    | /{}", f.prefix_len, s.prefix_len);
        println!("→ Хосты:");
        println!("   [1] {} - {}", f.min_host, f.max_host);
        println!("   [2] {} - {}", s.min_host, s.max_host);
        println!("----------------------------------------------\n");
    } else {
        println!("❗ Одна или обе сети не найдены!");
    }
}

// ─────────────────────────────────────────────
// Справка по командам
// ─────────────────────────────────────────────
/// Выводит список всех доступных команд и их краткое описание.
pub fn help() {
    println!("\n╔═══════════════════════════════════════════════╗");
    println!("║              📚 Доступные команды             ║");
    println!("╚═══════════════════════════════════════════════╝");
    println!("📌 add   - добавить новую сеть (требует IP и маску)");
    println!("📌 read  - просмотреть информацию о сети по ключу");
    println!("📌 upd   - обновить существующую сеть по ключу");
    println!("📌 del   - удалить сеть из базы по ключу");
    println!("📌 list  - показать список всех сохраненных сетей");
    println!("📌 cls   - очистить всю базу данных сетей");
    println!("📌 cmp   - сравнить две сети по их ключам");
    println!("📌 help  - показать этот список команд");
    println!("📌 exit  - выйти из программы");
    println!("═════════════════════════════════════════════════\n");
}

// ─────────────────────────────────────────────
// Сохранение и загрузка данных из JSON-файла
// ─────────────────────────────────────────────
/// Сохраняет текущее состояние базы данных сетевых конфигураций в JSON-файл по указанному пути.
///
/// ### Аргументы
///
/// * `db` - Неизменяемая ссылка на `HashMap`, содержащую сетевые конфигурации.
/// * `path` - Строковый срез, указывающий путь к файлу для сохранения.
///
/// ### Паника
///
/// Паникует, если не удается сериализовать данные в JSON или записать их в файл.
pub fn save_to_file(db: &HashMap<String, NetworkAnalyze>, path: &str) {
    let json: String = serde_json::to_string_pretty(db).unwrap();
    let mut writer: File = File::create(path).unwrap();
    writer.write_all(json.as_bytes()).unwrap();
    println!("Данные успешно сохранены в файл {}", path);
}

/// Загружает сетевые конфигурации из JSON-файла по указанному пути.
/// Если файл не существует или не может быть прочитан/разобран, возвращает пустую `HashMap`.
///
/// ### Аргументы
///
/// * `path` - Строковый срез, указывающий путь к файлу для загрузки.
///
/// ### Возвращает
///
/// `HashMap<String, NetworkAnalyze>` - Загруженная база данных сетевых конфигураций.
pub fn load_from_file(path: &str) -> HashMap<String, NetworkAnalyze> {
    let mut content: String = String::new();

    if let Ok(mut file) = File::open(path) {
        file.read_to_string(&mut content).unwrap();
        if let Ok(map) = serde_json::from_str::<HashMap<String, NetworkAnalyze>>(&content) {
            print!("📦 Загружено {} сетей из файла \"{}\"\n", map.len(), path);
            return map;
        }
    }

    HashMap::new()
}
