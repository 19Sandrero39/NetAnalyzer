/// Этот модуль предоставляет утилиту командной строки для анализа и управления сетевыми параметрами IPv4.
/// Программа позволяет пользователям добавлять, просматривать, обновлять, удалять,
/// выводить списком и сравнивать сетевые конфигурации, а также сохранять и загружать их из JSON-файла.
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::fs::File;
use std::io::{self, Read, Write};
use std::net::Ipv4Addr;

// ─────────────────────────────────────────────
// Вспомогательная функция для ввода с консоли
// ─────────────────────────────────────────────
/// Считывает строку ввода от пользователя с консоли, отображая заданный `prompt`.
///
/// # Аргументы
///
/// * `prompt` - Строковый срез, отображаемый пользователю перед вводом.
///
/// # Возвращает
///
/// `String` - Строка, введенная пользователем, с удаленными пробелами в начале и конце.
fn input(prompt: &str) -> String {
    let mut buf: String = String::new();
    print!("{}", prompt);
    io::stdout().flush().unwrap();
    io::stdin().read_line(&mut buf).unwrap();
    buf.trim().to_string()
}

// ─────────────────────────────────────────────
// Структура для хранения информации о сети
// ─────────────────────────────────────────────
/// Структура `NetworkAnalyze` хранит все вычисленные параметры для данной сетевой конфигурации IPv4.
#[derive(Debug, Deserialize, Serialize)]
struct NetworkAnalyze {
    /// IP-адрес, введенный пользователем.
    ip: Ipv4Addr,
    /// Маска подсети, введенная пользователем.
    mask: Ipv4Addr,
    /// Сетевой адрес подсети (результат побитового И IP и маски).
    network: Ipv4Addr,
    /// Минимальный адрес хоста в подсети (первый доступный IP).
    min_host: Ipv4Addr,
    /// Максимальный адрес хоста в подсети (последний доступный IP перед широковещательным адресом).
    max_host: Ipv4Addr,
    /// Адрес шлюза по умолчанию (обычно, но не всегда, совпадает с `min_host`).
    gateway: Ipv4Addr,
    /// Длина префикса подсети (количество единичных битов в маске подсети).
    prefix_len: u32,
    /// Количество доступных хостов в подсети.
    host_count: u32,
}

impl NetworkAnalyze {
    /// Создает новый экземпляр `NetworkAnalyze` с заданными параметрами.
    ///
    /// # Аргументы
    ///
    /// * `ip` - IP-адрес.
    /// * `mask` - Маска подсети.
    /// * `network` - Сетевой адрес.
    /// * `min_host` - Минимальный адрес хоста.
    /// * `max_host` - Максимальный адрес хоста.
    /// * `gateway` - Адрес шлюза по умолчанию.
    /// * `prefix_len` - Длина префикса.
    /// * `host_count` - Количество хостов.
    ///
    /// # Возвращает
    ///
    /// `Self` - Новый экземпляр `NetworkAnalyze`.
    fn new(
        ip: Ipv4Addr,
        mask: Ipv4Addr,
        network: Ipv4Addr,
        min_host: Ipv4Addr,
        max_host: Ipv4Addr,
        gateway: Ipv4Addr,
        prefix_len: u32,
        host_count: u32,
    ) -> Self {
        Self {
            ip,
            mask,
            network,
            min_host,
            max_host,
            gateway,
            prefix_len,
            host_count,
        }
    }
}

// ─────────────────────────────────────────────
// Расчёт параметров подсети по IP и маске
// ─────────────────────────────────────────────
/// Запрашивает у пользователя IP-адрес и маску подсети, затем вычисляет
/// различные параметры подсети, такие как сетевой адрес, длину префикса,
/// количество хостов, минимальный и максимальный адреса хостов, и шлюз.
///
/// # Возвращает
///
/// Кортеж, содержащий:
/// * `Ipv4Addr` - Введенный IP-адрес.
/// * `Ipv4Addr` - Введенная маска подсети.
/// * `Ipv4Addr` - Сетевой адрес.
/// * `Ipv4Addr` - Минимальный адрес хоста.
/// * `Ipv4Addr` - Максимальный адрес хоста.
/// * `Ipv4Addr` - Адрес шлюза.
/// * `u32` - Длина префикса.
/// * `u32` - Количество хостов.
///
/// # Паника
///
/// Паникует, если введенный IP-адрес или маска подсети не являются действительными форматами IPv4.
fn get_network() -> (
    Ipv4Addr,
    Ipv4Addr,
    Ipv4Addr,
    Ipv4Addr,
    Ipv4Addr,
    Ipv4Addr,
    u32,
    u32,
) {
    println!("\n╔═══════════════════════════════════════════════╗");
    println!("║             ⚙️ Введите данные сети            ║");
    println!("╚═══════════════════════════════════════════════╝");
    let ip_str: String = input("🔹 Введите IP-адрес: ");
    let mask_str: String = input("🔹 Введите маску подсети: ");
    println!("═════════════════════════════════════════════════\n");

    let ip: Ipv4Addr = ip_str
        .parse::<Ipv4Addr>()
        .expect("❌ Вы ввели неверный IP-адрес");

    let mask: Ipv4Addr = mask_str
        .parse::<Ipv4Addr>()
        .expect("❌ Вы ввели неверную маску подсети");

    let ip_u32: u32 = u32::from(ip);
    let mask_u32: u32 = u32::from(mask);
    let network_u32: u32 = ip_u32 & mask_u32;
    let network: Ipv4Addr = Ipv4Addr::from(network_u32);
    let prefix_len: u32 = mask_u32.count_ones();

    let host_count: u32 = if prefix_len < 31 {
        2u32.pow(32 - prefix_len) - 2
    } else {
        0
    };

    let min_host: Ipv4Addr = Ipv4Addr::from(network_u32 + 1);
    let broadcast_u32: u32 = network_u32 | !mask_u32;
    let max_host: Ipv4Addr = if host_count > 0 {
        Ipv4Addr::from(broadcast_u32 - 1)
    } else {
        network
    };

    let gateway: Ipv4Addr = min_host;

    (
        ip, mask, network, min_host, max_host, gateway, prefix_len, host_count,
    )
}

// ─────────────────────────────────────────────
// Создание новой записи сети
// ─────────────────────────────────────────────
/// Добавляет новую сетевую конфигурацию в базу данных.
/// Запрашивает у пользователя ключ для новой сети, а затем IP-адрес и маску.
/// Если ключ уже существует, пользователю сообщается об этом.
///
/// # Аргументы
///
/// * `db` - Изменяемая ссылка на `HashMap`, где ключ - это `String`, а значение - `NetworkAnalyze`.
fn create(db: &mut HashMap<String, NetworkAnalyze>) {
    println!("\n╔═══════════════════════════════════════════════╗");
    println!("║              ➕ Добавление новой сети         ║");
    println!("╚═══════════════════════════════════════════════╝");
    let key: String = input("🔹 Введите ключ для новой сети: ");

    if db.contains_key(&key) {
        println!(
            "❌ Сеть с ключом [{}] уже существует! Используйте 'upd' для обновления.",
            key
        );
        return;
    }

    let (ip, mask, network, min_host, max_host, gateway, prefix_len, host_count) = get_network();

    let new_network: NetworkAnalyze = NetworkAnalyze::new(
        ip, mask, network, min_host, max_host, gateway, prefix_len, host_count,
    );

    db.insert(key.clone(), new_network);
    println!("✅ Сеть с ключом [{}] успешно создана!", key);
    println!("═════════════════════════════════════════════════\n");
}

// ─────────────────────────────────────────────
// Чтение записи по ключу
// ─────────────────────────────────────────────
/// Отображает подробную информацию о сетевой конфигурации, используя указанный ключ.
/// Если сеть с заданным ключом не найдена, выводится сообщение об ошибке.
///
/// # Аргументы
///
/// * `db` - Неизменяемая ссылка на `HashMap`, содержащую сетевые конфигурации.
fn read(db: &HashMap<String, NetworkAnalyze>) {
    let key: String = input("🔹 Введите ключ сети для просмотра: ");
    match db.get(&key) {
        Some(info) => {
            println!("\n╔═══════════════════════════════════════════════╗");
            println!("║          📄 Информация о сети [{}]           ║", key);
            println!("╚═══════════════════════════════════════════════╝");

            println!("🔹 IP-адрес:            {}", info.ip);
            println!("🔹 Маска подсети:       {}", info.mask);
            println!("🔹 Сетевой адрес:       {}", info.network);
            println!("🔹 Длина префикса:      /{}", info.prefix_len);
            println!("🔹 Кол-во хостов:       {}", info.host_count);
            println!("🔹 Мин. адрес хоста:    {}", info.min_host);
            println!("🔹 Макс. адрес хоста:   {}", info.max_host);
            println!("🔹 Шлюз по умолчанию:   {}", info.gateway);
            println!("═════════════════════════════════════════════════\n");
        }
        None => println!("❌ Сеть с ключом [{}] не найдена!", key),
    }
}

// ─────────────────────────────────────────────
// Обновление существующей записи
// ─────────────────────────────────────────────
/// Обновляет существующую сетевую конфигурацию в базе данных.
/// Запрашивает ключ сети для обновления, затем запрашивает новые IP-адрес и маску.
/// Если сеть с заданным ключом не найдена, выводится сообщение об ошибке.
///
/// # Аргументы
///
/// * `db` - Изменяемая ссылка на `HashMap`, где ключ - это `String`, а значение - `NetworkAnalyze`.
fn update(db: &mut HashMap<String, NetworkAnalyze>) {
    println!("\n╔═══════════════════════════════════════════════╗");
    println!("║            🔄 Обновление данных сети          ║");
    println!("╚═══════════════════════════════════════════════╝");
    let key: String = input("🔹 Введите ключ сети для обновления: ");

    if db.contains_key(&key) {
        println!("➡️ Введите новые данные для пересчёта:");

        let (ip, mask, network, min_host, max_host, gateway, prefix_len, host_count) =
            get_network();

        let updated_network: NetworkAnalyze = NetworkAnalyze::new(
            ip, mask, network, min_host, max_host, gateway, prefix_len, host_count,
        );

        db.insert(key.clone(), updated_network);
        println!("✅ Сеть с ключом [{}] успешно обновлена!", key);
    } else {
        println!("❌ Сеть с ключом [{}] не найдена!", key);
    }
    println!("═════════════════════════════════════════════════\n");
}

// ─────────────────────────────────────────────
// Удаление записи
// ─────────────────────────────────────────────
/// Удаляет сетевую конфигурацию из базы данных по указанному ключу.
/// Если сеть с заданным ключом не найдена, выводится сообщение об ошибке.
///
/// # Аргументы
///
/// * `db` - Изменяемая ссылка на `HashMap`, где ключ - это `String`, а значение - `NetworkAnalyze`.
fn delete(db: &mut HashMap<String, NetworkAnalyze>) {
    println!("\n╔═══════════════════════════════════════════════╗");
    println!("║             🗑️ Удаление сети                  ║");
    println!("╚═══════════════════════════════════════════════╝");
    let key: String = input("🔹 Введите ключ сети для удаления: ");
    if db.remove(&key).is_some() {
        println!("✅ Сеть с ключом [{}] успешно удалена из базы!", key);
    } else {
        println!("❌ Мы не смогли найти сеть по указанному ключу [{}]!", key);
    }
    println!("═════════════════════════════════════════════════\n");
}

// ─────────────────────────────────────────────
// Вывод всех сетей
// ─────────────────────────────────────────────
/// Выводит список всех сохраненных сетевых конфигураций в базе данных.
/// Если база данных пуста, выводится соответствующее сообщение.
///
/// # Аргументы
///
/// * `db` - Неизменяемая ссылка на `HashMap`, содержащую сетевые конфигурации.
fn list(db: &HashMap<String, NetworkAnalyze>) {
    println!("\n╔═══════════════════════════════════════════════╗");
    println!("║              📋 Список всех сетей             ║");
    println!("╚═══════════════════════════════════════════════╝");
    if db.is_empty() {
        println!("ℹ️ База данных пуста! Добавьте сети командой 'add'.");
    } else {
        for (key, net) in db {
            println!("➡️ Ключ: [{}]", key);
            println!("  IP-адрес: {}", net.ip);
            println!("  Маска: {}", net.mask);
            println!("  Сетевой адрес: {}", net.network);
            println!("  Длина префикса: /{}", net.prefix_len);
            println!("  Кол-во хостов: {}", net.host_count);
            println!("  Мин. хост: {}", net.min_host);
            println!("  Макс. хост: {}", net.max_host);
            println!("  Шлюз: {}", net.gateway);
            println!("-----------------------------------------------");
        }
    }
    println!("═════════════════════════════════════════════════\n");
}

// ─────────────────────────────────────────────
// Очистка всей базы
// ─────────────────────────────────────────────
/// Очищает всю базу данных сетевых конфигураций.
/// Перед выполнением операции запрашивает у пользователя подтверждение.
///
/// # Аргументы
///
/// * `db` - Изменяемая ссылка на `HashMap`, где ключ - это `String`, а значение - `NetworkAnalyze`.
fn clear(db: &mut HashMap<String, NetworkAnalyze>) {
    println!("\n╔═══════════════════════════════════════════════╗");
    println!("║             ⚠️ Очистка всей базы               ║");
    println!("╚═══════════════════════════════════════════════╝");
    let confirm: String = input("⚠️ Вы уверены, что хотите удалить ВСЕ сети? (yes/no): ");
    if confirm.to_lowercase() == "yes" {
        db.clear();
        println!("✅ Все сети были успешно удалены!");
    } else {
        println!("❌ Операция отменена.");
    }
    println!("═════════════════════════════════════════════════\n");
}

// ─────────────────────────────────────────────
// Сравнение двух сетей
// ─────────────────────────────────────────────
/// Сравнивает две сетевые конфигурации по их ключам, указанным пользователем.
/// Выводит, находятся ли сети в одной подсети, и отображает их ключевые параметры для сравнения.
/// Если одна или обе сети не найдены, выводится сообщение об ошибке.
///
/// # Аргументы
///
/// * `db` - Неизменяемая ссылка на `HashMap`, содержащую сетевые конфигурации.
fn compare(db: &HashMap<String, NetworkAnalyze>) {
    println!("\n╔═══════════════════════════════════════════════╗");
    println!("║              📊 Сравнение двух сетей          ║");
    println!("╚═══════════════════════════════════════════════╝");
    let first_key: String = input("🔹 Введите ключ первой сети [1]: ");
    let second_key: String = input("🔹 Введите ключ второй сети [2]: ");
    println!("═════════════════════════════════════════════════\n");

    let first: Option<&NetworkAnalyze> = db.get(&first_key);
    let second: Option<&NetworkAnalyze> = db.get(&second_key);

    if let (Some(f), Some(s)) = (first, second) {
        println!(
            "🔍 Результат сравнения сетей [{}] и [{}]",
            first_key, second_key
        );
        println!("----------------------------------------------");

        if f.network == s.network && f.mask == s.mask {
            println!("✅ Сети находятся в одной подсети!");
        } else {
            println!("❌ Сети находятся в разных подсетях.");
        }

        println!("→ IP [1]:   {}    | IP [2]:   {}", f.ip, s.ip);
        println!("→ Сеть:     {}    | {}", f.network, s.network);
        println!("→ Маска:    {}    | {}", f.mask, s.mask);
        println!("→ Префикс:  /{}    | /{}", f.prefix_len, s.prefix_len);
        println!("→ Хосты:");
        println!("   [1] {} - {}", f.min_host, f.max_host);
        println!("   [2] {} - {}", s.min_host, s.max_host);
        println!("----------------------------------------------\n");
    } else {
        println!("❗ Одна или обе сети не найдены!");
    }
}

// ─────────────────────────────────────────────
// Справка по командам
// ─────────────────────────────────────────────
/// Выводит список всех доступных команд и их краткое описание.
fn help() {
    println!("\n╔═══════════════════════════════════════════════╗");
    println!("║              📚 Доступные команды             ║");
    println!("╚═══════════════════════════════════════════════╝");
    println!("📌 add   - добавить новую сеть (требует IP и маску)");
    println!("📌 read  - просмотреть информацию о сети по ключу");
    println!("📌 upd   - обновить существующую сеть по ключу");
    println!("📌 del   - удалить сеть из базы по ключу");
    println!("📌 list  - показать список всех сохраненных сетей");
    println!("📌 cls   - очистить всю базу данных сетей");
    println!("📌 cmp   - сравнить две сети по их ключам");
    println!("📌 help  - показать этот список команд");
    println!("📌 exit  - выйти из программы");
    println!("═════════════════════════════════════════════════\n");
}

// ─────────────────────────────────────────────
// Сохранение и загрузка данных из JSON-файла
// ─────────────────────────────────────────────
/// Сохраняет текущее состояние базы данных сетевых конфигураций в JSON-файл по указанному пути.
///
/// # Аргументы
///
/// * `db` - Неизменяемая ссылка на `HashMap`, содержащую сетевые конфигурации.
/// * `path` - Строковый срез, указывающий путь к файлу для сохранения.
///
/// # Паника
///
/// Паникует, если не удается сериализовать данные в JSON или записать их в файл.
fn save_to_file(db: &HashMap<String, NetworkAnalyze>, path: &str) {
    let json = serde_json::to_string_pretty(db).unwrap();
    let mut writer = File::create(path).unwrap();
    writer.write_all(json.as_bytes()).unwrap();
    println!("Данные успешно сохранены в файл {}", path);
}

/// Загружает сетевые конфигурации из JSON-файла по указанному пути.
/// Если файл не существует или не может быть прочитан/разобран, возвращает пустую `HashMap`.
///
/// # Аргументы
///
/// * `path` - Строковый срез, указывающий путь к файлу для загрузки.
///
/// # Возвращает
///
/// `HashMap<String, NetworkAnalyze>` - Загруженная база данных сетевых конфигураций.
fn load_from_file(path: &str) -> HashMap<String, NetworkAnalyze> {
    let mut content = String::new();

    if let Ok(mut file) = File::open(path) {
        file.read_to_string(&mut content).unwrap();
        if let Ok(map) = serde_json::from_str::<HashMap<String, NetworkAnalyze>>(&content) {
            print!("📦 Загружено {} сетей из файла \"{}\"\n", map.len(), path);
            return map;
        }
    }

    HashMap::new()
}

// ─────────────────────────────────────────────
// Основной цикл командной оболочки
// ─────────────────────────────────────────────
/// Главная функция программы NetAnalyzer.
/// Инициализирует базу данных сетей, загружает данные из `network.json` (если он существует),
/// затем входит в бесконечный цикл, обрабатывающий команды пользователя.
/// Поддерживает команды: `add`, `read`, `upd`, `del`, `list`, `cls`, `cmp`, `help`, `exit`.
/// Сохраняет изменения в файл `network.json` после операций `add`, `upd`, `del`, `cls`.
fn main() {
    let path = "network.json";
    let mut db = load_from_file(path);

    println!("\n╔═══════════════════════════════════════════════╗");
    println!("║       👋 Добро пожаловать в NetAnalyzer!      ║");
    println!("╚═══════════════════════════════════════════════╝");
    help(); // Display help message on startup

    loop {
        let command = input("🌐 Введите команду (или 'help' для списка команд): ");

        match command.as_str() {
            "add" => {
                create(&mut db);
                save_to_file(&db, path);
            }
            "read" => read(&db),
            "upd" => {
                update(&mut db);
                save_to_file(&db, path);
            }
            "del" => {
                delete(&mut db);
                save_to_file(&db, path);
            }
            "list" => list(&db),
            "cls" => {
                clear(&mut db);
                save_to_file(&db, path);
            }
            "cmp" => compare(&db),
            "help" => help(),
            "exit" => {
                println!("👋 До свидания! Данные сохранены.");
                break;
            }
            _ => println!("❓ Неизвестная команда! Введите 'help' для просмотра доступных команд."),
        }
    }
}
